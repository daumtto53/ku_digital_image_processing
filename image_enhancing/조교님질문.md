조교님 안녕하세요,

Color space의 negative 변환과제를 하던 중 RGB -> HSI -> RGB space로의 변환과정에서 질문이 있어 연락드립니다.

HSI channel을 각각 뽑은 channel을 H, S, I 라고 할때,
Color space의 색조 유지를 하는 negative transformation을 하기 위해 RGB channel 에서 I 만 negative 시킨 I' 를 재료로
H, S, I' channel을 HSI -> RGB 영역으로 아래의 변환공식을 통해 진행한다고 알고있습니다.

<수업 PPT입니다. >

여기서 H는 degree단위고, s는 normalized된 saturity인 것으로 알고 있습니다.

이 변환공식을 코드로 작성하였을 때, 결과 이미지가 다르게 나옵니다.

구현은 아래와 같이 하였고,

```python
def HSI_to_bgr(h, s, i):
    h = degrees(h)
    if 0 < h <= 120 :
        b = i * (1 - s)
        r = i * (1 + (s * cos(h) / cos(60 - h)))
        g = i * 3 - (r + b)
    elif 120 < h <= 240:
        # h -= 120
        r = i * (1 - s)
        g = i * (1 + (s * cos(h) / cos(60 - h)))
        b = 3 * i - (r + g)
    elif 240 < h <= 360:
        # h -= 240
        g = i * (1 - s)
        b = i * (1 + (s * cos(h) / cos(60 - h)))
        r = i * 3 - (g + b)
```

h는 degree로 계산하였으며

s는 아래와 같이 계산하였습니다.

```python
            b = src[i][j][0] / 255.
            g = src[i][j][1] / 255.
            r = src[i][j][2] / 255. 일 

def rgb_to_saturity(b, g, r):
    if r + g + b != 0:
        return 1 - 3 * np.min([r, g, b]) / (r + g + b)
    else:
        return 0
```

그 결과로 얻어진 r,g,b 값에 정규화한 255를 곱하여

```python
            new_image[i][j][0] = bgr_tuple[0] * 255.
            new_image[i][j][1] = bgr_tuple[1] * 255.
            new_image[i][j][2] = bgr_tuple[2] * 255.
```

new image에다 hsi 를 rgb로 출력한 결과를 출력해보았으나,

변환 결과가 기대하던 대로 나오지 않아, 혹시 HSI -> RGB 변환에의 공식에 문제가 있지 않았나 싶어 질문드립니다.
